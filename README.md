# Сервис для анализа временных рядов

## TODO

- анализ + предсказание
  - фронт - сделать интерфейс по шаблону (замокать запросы на анализ и предсказание). описать ряд + построить исходный плот + справка про модели и их стоимость

- redis + redis queue
  - обновить readme (добавить картинку мб)
  - добавить очередь задач для анализа и предсказания
  - описать модель данных (хотя мб и не надо)

- транзакции

- демо
- локальный запуск
- docker
- tree structure
- .env

## Принцип работы

- Пользователь регистрируется/авторизуется.
- Пользователь загружает свой временной ряд.
- Пользователь может сделать статистический анализ временного ряда.
- Пользователь может получить предсказания будущих значений, выбрав подходящую модель.
- У пользователя есть баланс, с которого будут списаны средства за анализ или предсказание.
- Пользователь может скачать предобработанный временной ряд или предсказанные значения.

## Демо

TODO

Сюда вставить скриншоты интерфейса, баз данных, а также ссылку на видео-демо.

## Компоненты системы

- Регистрация/аутентификация.
- Биллинг.
- Загрузка/скачивание временных рядов.
- Анализ временного ряда.
- Предсказание временного ряда.
- Интерфейс.

### Регистрация/аутентификация

Регистрация/аутентификация пользователя по логину и паролю.

Данный модуль реализован с помощью `FastAPI.security`, а именно используя парадингму OAuth2 на основе классов `OAuth2PasswordBearer`, `OAuth2PasswordRequestForm`. Делал я это по этим [официальным докам FastAPI](https://fastapi.tiangolo.com/tutorial/security/).

Принцип работы: 

- У меня есть бекенд (с различными эндпоинтами, реализованный через `FastAPI`) и фронтенд (реализованный на `streamlit`).
- В данном конкретном случае (т.н. *password flow в OAuth2*) бекенд будет как реализовывать API, так и проводить аутентификацию пользователя.
- Итак, алгоритм:
  - Пользователь вводит логин и пароль на фронтенде.
  - Фронтенд отправляет их в бекенд API.
  - Бекенд API проверяет данные и возвращает токен - строку, подтверждающую пользователя. Токен имеет некоторый lifetime. В качестве токена использую JWT (с помощью библиотеки `PyJWT`).
  - Фронтенд временно сохраняет токен.
  - При переходе на другую часть приложения фронтенд запрашивает данные у API и для авторизации отправляет в заголовке к запросу этот токен.
  - Бекенд API проверяет токен и если он действителен, то отдает данные.

Пароли хэшировать буду с помощью библиотеки `passlib`, используя алгоритм `Bcrypt`.

Для того, чтобы создавались секьюрные JWT необходимо создать secure random secret key с помощью этой команды:

```bash
openssl rand -hex 32
```

Результатом будет строка, которую требуется положить в файл `.env` с названием SECRET_KEY.

### Биллинг

У каждого пользователя есть баланс, который проверяется при попытке пользователя сделать анализ/предсказание по загруженному временному ряду.

Пополнение баланса сделано искусственное (пользователь может ввести любую сумму и баланс пополнится).

Стоимость услуг рассчитывается следующим образом:

- Бесплатно: загрузка, хранение, отображение, анализ, скачивание временных рядов.
- $ x_i \cdot length(timeseries) $, где $x_i$ - фиксированная цена предсказания одной временной точки (разная для каждой модели). То есть цена рассчитывается динамически в зависимости от требуемого пользователем горизонта прогнозирования. 

Вся информация о стоимости и о моделях находится в [models_info.json](./src/data/models_info.json) и подгружается в БД при ее старте в таблицу `models`. То есть для того, чтобы поменять тарифы потребуется лишь написать SQL-запросы которые изменят данные в таблице `models`.

### Загрузка/скачивание временных рядов

При загрузке пользователем временного ряда, данные проверяются на следование формату, пропуски и размеры. Если ряд удовлетворяет всем требованиям, то он сохраняется в базе данных (таблица `ts`).

Также есть возможность выгружать следующие временные ряды из базы данных:

- Исходный временной ряд, загруженный пользователем.
- Сглаженный с помощью EMA временной ряд.
- Предсказанные временной ряд моделью.

### Анализ временного ряда

Данный модуль будет проводить действия:

- Построение графиков:

  - Исходный временной ряд.
  - Сглаженный временной ряд (exponential moving average).

- Расчет простых статистик:

  - Среднее, медиана, стандартное отклонение, 25-й и 75-й квартили.
  - Минимальное и максимальное значения.
  - 3 наиболее и наименее частотные значения.

- Частотный анализ - наиболее значимые частоты используя преобразования Фурье.
- Статистические тесты:

  - Тест Манна-Кендалла на проверку наличия тренда. Также отобразим линейный тренд на исходном временном ряде.
  - Тест ARCH на проверку гетероскедастичности ряда. Также построим график остатков временного ряда от линейного тренда.

### Предсказание временного ряда

Данный модуль будет обучать статистические модели для предсказания временных рядов.

Все модели реализованы в библиотеке `statsforecast`:

- Модель экспоненциального скользящего среднего (ETS).
- Модель ARIMA.
- Модель Theta.
- Модель TBATS.

Также дадим предсказания наивными моделями:

- Модель среднего.
- Модель линейного тренда.

Предсказанные временные ряды и модели будут сохранены в базе данных (таблицы `series` и `trained_models`), отображены в интерфейсе, а также доступны для скачивания.

### Интерфейс

Использую библиотеку `streamlit` для построения интерфейса.

Интерфейс представляет собой несколько страниц (каждая страница - отдельный смысловой модуль, с общим контекстом и sidebar-ом). Разработка полностью основана на [этом официальном туториале библиотеки](https://docs.streamlit.io/get-started/tutorials/create-a-multipage-app).

В контексте интерфейса сохраняю следующие сущности (для сохранения сессионности и безопасности):

- JWT токен (который требуется для каждого эндпоинта, чтобы аутентифицировать пользователя).
- Модель данных текущего пользователя.
- Флаг аутентификации.

Использование библиотеки `streamlit` на каждый инстанс (например, открытую вкладку в браузере) создает отдельную сессию (внутри который мы уже используем JWT).

## Дизайн сервиса

### Бекенд

Весь бекэнд реализую с помощью `FastAPI` - это позволит обрабатывать все запросы к эндпоинтам (запросы на анализ и предсказание временного ряда будут попадать в очередь задач, чтобы не блокировать FastAPI клиент) в асинхронном режиме.

### Очереди задач для долгих вычислений

Использование очереди задач для анализа и предсказания нам нужны, чтобы не блокировать наш FastAPI клиент (будем ждать пока запрос посчитается). Поэтому при запросе на анализ/предсказание мы будем делать так:

- Эндпоинт принимает запрос в обработку и сразу возвращает task_id.
- Воркеры выбирают задачи, выполняют их и обновляют статус/результаты в базе данных.
- Интерфейс может опрашивать серверную часть для получения статуса задачи.

Соответственно для реализации этого использую:

- `Celery` - для создание процессов, которые будут выполнять тяжелые задачи (анализ временного ряда, обучение модели и предсказание будущих значений временного ряда) вне процесса FastAPI (чтобы его не блокировать).
- `Redis` - в качестве очереди задач (эндпоинт складывает задачу в очередь, на которую подписаны воркеры Celery).

### Работа с данными

Для хранения данных буду использовать in-memory БД `SQLite`, а для работы с БД библиотеку `SQLAlchemy`.

Соответственно есть следующие модели данных в виде таблиц:

- users:
  - id
  - login
  - hashed_password: str
  - name - имя пользователя в сервисе
  - balance
  - time_series - список временных рядов, принадлежащих данному пользователю

- time_series:
  - id
  - user_id - id пользователя, которому принадлежит временной ряд
  - name - название временного ряда
  - created_at - дата создания временного ряда
  - len - длина временного ряда
  - data - сам временной ряд в формате list[float]
  - analysis_results - результаты анализа временного ряда в формате json
  - forecasting_ts - id-шники временных рядов предсказанных моделями

- models:
  - id
  - name - название модели
  - info - информация о модели
  - tariffs - стоимость использования модели (за одну точку пресказания) для предсказания временного ряда

Для хранения задач (для воркеров Celery) будем использовать следующую модель данных:

- tasks: id, user_id, type, status, result, created_at, updated_at.

## Структура проекта

```
├── Project requirements.md
├── python-version
├── README.md
├── requirements.txt
└── src
    ├── analyze.py - модуль для анализа временного ряда
    ├── app.py - модуль с определением эндпоинтов FastAPI
    ├── contracts.py - контракты API
    ├── data
    │   └── models_info.json - информация о моделях (загружается в БД при запуске проекта)
    ├── data_models.py - модели данных ЬД
    ├── db.py - модуль для работы с БД (создание таблиц, загрузка данных в БД, получение данных из БД, создание сессии)
    ├── forecast.py - модуль для предсказания временного ряда
    ├── frontend.py - фронтенд на `streamlit`
    ├── security.py - модуль для работы с JWT токенами и хеширования паролей
    └── validate_series.py - модуль для валидации временного ряда
```

## Пример dotenv файла

```
# JWT settings
SECRET_KEY=RANDOM_SECRET_KEY
ALGORITHM=HS256
ACESS_TOKEN_EXPIRE_MINUTES=30
```

## Локальный запуск проекта

TODO