# Сервис для анализа временных рядов

## Принцип работы

- Пользователь регистрируется/авторизуется.
- Пользователь загружает свой временной ряд.
- Пользователь может сделать статистический анализ временного ряда.
- Пользователь может получить предсказания будущих значений, выбрав подходящую модель.
- У пользователя есть баланс, с которого будут списаны средства за анализ или предсказание.
- Пользователь может скачать предобработанный временной ряд или предсказанные значения.

## Демо

TODO

Сюда вставить скриншоты интерфейса, баз данных, а также ссылку на видео-демо.

## Компоненты системы

- Регистрация/аутентификация.
- Биллинг.
- Загрузка/скачивание временных рядов.
- Анализ временного ряда.
- Предсказание временного ряда.
- Интерфейс.

### Регистрация/аутентификация

Регистрация/аутентификация пользователя по логину и паролю.

Логин и пароль хранятся в таблице `credentials` (пароль в зашифрованном виде).

### Биллинг

У каждого пользователя есть баланс (хранится в таблице `balance`), который проверяется при попытке пользователя сделать анализ/предсказание по загруженному временному ряду.

Пополнение баланса сделано искусственное (пользователь может ввести любую сумму и баланс пополнится).

### Загрузка/скачивание временных рядов

При загрузке пользователем временного ряда, данные проверяются на следование формату, пропуски и размеры. Если ряд удовлетворяет всем требованиям, то он сохраняется в базе данных (таблица `series`).

Также есть возможность загружать временные ряды из базы данных.

### Анализ временного ряда

Данный модуль будет проводить действия:

- Построение графиков:

  - Исходный временной ряд.
  - Сглаженный временной ряд (exponential moving average). Также есть возможность скачать этот вариант ряда.

- Расчет простых статистик:

  - Среднее, медиана, стандартное отклонение, 25-й и 75-й квартили.
  - Минимальное и максимальное значения.
  - 3 наиболее и наименее частотные значения.

- Частотный анализ - наиболее значимые частоты используя преобразования Фурье.
- Статистические тесты:

  - Тест Манна-Кендалла на проверку наличия тренда. Также отобразим линейный тренд на исходном временном ряде.
  - Тест ARCH на проверку гетероскедастичности ряда. Также построим график остатков временного ряда от линейного тренда.

### Предсказание временного ряда

Данный модуль будет обучать статистические модели для предсказания временных рядов.

Все модели реализованы в библиотеке `statsforecast`:

- Модель экспоненциального скользящего среднего (ETS).
- Модель ARIMA.
- Модель Theta.
- Модель TBATS.

Также дадим предсказания наивными моделями:

- Модель среднего.
- Модель линейного тренда.

Предсказанные временные ряды и модели будут сохранены в базе данных (таблицы `series` и `trained_models`), отображены в интерфейсе, а также доступны для скачивания.

### Интерфейс

Использую библиотеку `streamlit` для построения интерфейса.

## Дизайн сервиса

### Бекенд

Весь бекэнд реализую с помощью `FastAPI` - это позволит обрабатывать все запросы к эндпоинтам (запросы на анализ и предсказание временного ряда будут попадать в очередь задач, чтобы не блокировать FastAPI клиент) в асинхронном режиме.

### Очереди задач для долгих вычислений

Использование очереди задач для анализа и предсказания нам нужны, чтобы не блокировать наш FastAPI клиент (будем ждать пока запрос посчитается). Поэтому при запросе на анализ/предсказание мы будем делать так:

- Эндпоинт принимает запрос в обработку и сразу возвращает task_id.
- Воркеры выбирают задачи, выполняют их и обновляют статус/результаты в базе данных.
- Интерфейс может опрашивать серверную часть для получения статуса задачи.

Соответственно для реализации этого использую:

- `Celery` - для создание процессов, которые будут выполнять тяжелые задачи (анализ временного ряда, обучение модели и предсказание будущих значений временного ряда) вне процесса FastAPI (чтобы его не блокировать).
- `Redis` - в качестве очереди задач (эндпоинт складывает задачу в очередь, на которую подписаны воркеры Celery).

### Работа с данными

Для хранения данных буду использовать БД `PostgreSQL`, а для работы с БД библиотеку `SQLAlchemy`.

Соответственно есть следующие модели данных в виде таблиц:

- credentials: user_id, login, password_hash - логин и пароль пользователя в зашифрованном виде.
- balance: user_id, balance - данные о текущем балансе пользователя.
- transactions: transaction_id, user_id, type, amount, created_at - таблица с историей транзакций пользователей.
- models: model_id, name, info - данные о имеющихся моделях (название и описание).
- tariffs: model_id, price - данные о стоимости использования модели для предсказания временного ряда.
- series: series_id, user_id, name, data, created_at - таблица с временными рядами, так как мы ограничим размер временных рядов, то можем просто хранить их как JSONB (напримtest_trend, ер: [{timestamp: "2024-01-01", value: 10.2}, ...]).
- stats: id, series_id, mean, mode, std, q25, q75, min, max, most_frequent, least_frequent, hist, smoothed, fourier_freqs, trend_test_pval, trend, het_test_pval, residuals - данные со статистиками, полученные при анализе временного ряда.
- trained_models: id, series_id, model_id, model_object - обученные модели на временных рядах (модель будем хранить как binary blob, полученный с помощью joblib).
- predictions: id, model_id, series_id, data - временной ряд с предсказаниями.

Для хранения задач (для воркеров Celery) будем использовать следующую модель данных:

- tasks: id, user_id, type, status, result, created_at, updated_at.

## Локальный запуск проекта

TODO